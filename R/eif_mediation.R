#' Compute the Shift Parameter Estimate and the Efficient Influence Function for
#' Mediation
#'
#' @details Estimate the value of the causal parameter alongside statistical
#'  inference for the parameter estimate based on the efficient influence
#'  function of the target parameter, which takes the following form:
#'  %D(P)(o) = H(a,w)(y - \bar{Q}(a,w)) + \bar{Q}(d(a,w)) - \psi(P)
#'
#' @param Y A \code{numeric} vector of the observed outcomes.
#' @param Qn An object providing the value of the outcome evaluated after
#'  imposing a shift in the treatment. This object is passed in after being
#'  constructed by a call to the internal function \code{est_Q}.
#' @param Hn An object providing values of the auxiliary ("clever") covariate,
#'  constructed from the treatment mechanism and required for targeted minimum
#'  loss-based estimation. This object object should be passed in after being
#'  constructed by a call to the internal function \code{est_Hn}.
#' @param estimator The type of estimator to be fit, either \code{"tmle"} for
#'  targeted maximum likelihood estimation or \code{"onestep"} for a one-step
#'  estimator.
#' @param C_samp Indicator for missingness due to exclusion from second-phase
#'  sample. Used for compatibility with the IPCW-TML estimation routine.
#' @param ipc_weights A \code{numeric} vector that gives inverse probability of
#'  censoring weights for each observation. These are generated by invoking the
#'  routines for estimating the censoring mechanism.
#' @param fluc_mod_out An object giving values of the logistic tilting model
#'  for targeted minimum loss estimation. This type of object should be the
#'  output of the internal routines to perform this step of the TML estimation
#'  procedure, as given by \code{\link{fit_fluctuation}}.
#'
#' @importFrom stats var
#'
#' @return A \code{list} containing the parameter estimate, estimated variance
#'  based on the efficient influence function (EIF), the estimate of the EIF
#'  incorporating inverse probability of censoring weights, and the estimate of
#'  the EIF without the application of such weights.
eif_mediation <- function(y,
                          qn,
                          hn,
                          estimator = c("tmle", "onestep"),
                          fluc_mod_out = NULL) {
  # set TMLE as default estimator type
  estimator <- match.arg(estimator)

  # set Qn to use based on estimator type
  if (estimator == "tmle") {
    qn_a_shift <- fluc_mod_out$qn_a_shift_star
    qn_az_shift <- fluc_mod_out$qn_a_z_shift_star
    qn_noshift <- fluc_mod_out$qn_noshift_star
  } else if (estimator == "onestep") {
    qn_shift <- qn$upshift
    qn_noshift <- qn$noshift
  }

  psi_a_shift <- mean(qn_a_shift)
  psi_az_shift <- mean(qn_az_shift)
  noshift_psi <- mean(qn_noshift)

  nde <- psi_a_shift - noshift_psi
  nie <- psi_az_shift - psi_a_shift

  eif_a <-
    (hn$hn_no_shift * (y - qn_noshift) + (qn_a_shift - psi_a_shift))

  eif_az <-
    (hn$hn_no_shift * (y - qn_noshift) + (qn_az_shift - psi_az_shift))

  eif_no_shift <- y - qn_noshift

  nie_eif <- eif_az - eif_a
  nde_eif <- eif_a - eif_no_shift

  # add mean of EIF to parameter estimate if fitting one-step
  # NOTE: the estimate of psi is updated _after_ evaluating the EIF
  if (estimator == "onestep") {
    psi <- psi + mean(eif)
  }

  # compute the variance based on the EIF and scale by number of observations
  var_nie <- stats::var(nie_eif) / length(y)
  var_nde <- stats::var(nde_eif) / length(y)
  # var_noshift_eif <- stats::var(eif_no_shift) / length(y)

  # compute the confidence intervales based on the EIF
  se_nie <- sqrt(var_nie)
  se_nde <- sqrt(var_nde)
  # se_noshift <- sqrt(var_noshift_eif)

  CI_nie <- c(
    round(nie + stats::qnorm(0.05 / 2, lower.tail = T) * se_nie, 4),
    round(nie + stats::qnorm(0.05 / 2, lower.tail = F) * se_nie, 4)
  )

  CI_nde <- c(
    round(nde + stats::qnorm(0.05 / 2, lower.tail = T) * se_nde, 4),
    round(nde + stats::qnorm(0.05 / 2, lower.tail = F) * se_nde, 4)
  )


  p_value_nde <- round(2 * stats::pnorm(abs(nde / se_nde), lower.tail = F), 6)
  p_value_nie <- round(2 * stats::pnorm(abs(nie / se_nie), lower.tail = F), 6)

  # return the variance and the EIF value at each observation
  out <- list(
    nde = nde,
    nie = nie,
    se_nde <- se_nde,
    se_nie <- se_nie,
    CI_nde <- CI_nde,
    CI_nie <- CI_nie,
    p_value_nde <- p_value_nde,
    p_value_nie <- p_value_nie,
    nde_eif = nde_eif,
    nie_eif = nie_eif
  )

  names(out) <- c(
    "nde", "nie", "se_nde", "se_nie", "CI_nde", "CI_nie",
    "p_value_nde", "p_value_nie", "nde_eif", "nie_eif"
  )
  return(out)
}
